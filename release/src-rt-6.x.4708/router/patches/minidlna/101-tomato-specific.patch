--- minidlna/config.h	1969-12-31 21:00:00.000000000 -0300
+++ minidlna/config.h	2017-09-06 01:28:18.000000000 -0300
@@ -0,0 +1,51 @@
+/* MiniDLNA Project
+ * http://sourceforge.net/projects/minidlna/
+ * (c) 2008-2009 Justin Maggard */
+#ifndef __CONFIG_H__
+#define __CONFIG_H__
+
+#define OS_NAME			"Tomato"
+#define OS_VERSION		"Linux/2.6.36.4brcmarm"
+#define OS_URL			"http://tomatousb.org/"
+
+#define HAVE_CLOCK_GETTIME 1
+#define HAVE_CLOCK_GETTIME_SYSCALL 1
+#define HAVE_GETIFADDRS 1
+#define HAVE_INOTIFY 1
+#define HAVE_LIBAVCODEC_AVCODEC_H 1
+#define HAVE_LIBAVFORMAT_AVFORMAT_H 1
+#define HAVE_LIBAVUTIL_AVUTIL_H 1
+#define HAVE_LINUX_SENDFILE_API 1
+#define HAVE_SENDFILE 1
+#define HAVE_SQLITE3_MALLOC 1
+#define HAVE_SQLITE3_PREPARE_V2 1
+#define HAVE_SYS_INOTIFY_H 1
+#define SCANDIR_CONST 1
+
+/* full path of the file database */
+#define DEFAULT_DB_PATH		"/tmp/minidlna"
+
+/* full path of the log directory */
+#define DEFAULT_LOG_PATH	"/var/log"
+
+/* Enable if the system inotify.h exists.  Otherwise our own inotify.h will be used. */
+#ifdef LINUX26
+#define HAVE_INOTIFY_H
+#endif
+
+/* Enable if the system iconv.h exists.  ID3 tag reading in various character sets will not work properly otherwise. */
+/* #define HAVE_ICONV_H */
+
+/* Enable if the system libintl.h exists for NLS support. */
+/* #define ENABLE_NLS */
+
+/* Enable NETGEAR-specific tweaks. */
+/*#define NETGEAR*/
+/* Enable ReadyNAS-specific tweaks. */
+/*#define READYNAS*/
+/* Compile in TiVo support. */
+#define TIVO_SUPPORT
+/* Enable PnPX support. */
+#define PNPX 0
+
+#endif
--- minidlna/getifaddr.c	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/getifaddr.c	2017-09-06 01:28:18.000000000 -0300
@@ -65,6 +65,7 @@
 #include "minissdp.h"
 #include "utils.h"
 #include "log.h"
+#include "ifaddrs.c"
 
 static int
 getifaddr(const char *ifname)
--- minidlna/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ minidlna/Makefile	2017-09-06 01:28:18.000000000 -0300
@@ -0,0 +1,168 @@
+# $Id: Makefile,v 1.31.2.2 2012/11/05 07:01:21 jmaggard Exp $
+# MiniDLNA project
+# http://sourceforge.net/projects/minidlna/
+# (c) 2008-2009 Justin Maggard
+# for use with GNU Make
+# To install use :
+# $ DESTDIR=/dummyinstalldir make install
+# or :
+# $ INSTALLPREFIX=/usr/local make install
+# or :
+# $ make install
+#
+#CFLAGS = -Wall -O -D_GNU_SOURCE -g -DDEBUG
+#CFLAGS = -Wall -g -Os -D_GNU_SOURCE
+
+include ../common.mak
+
+LDFLAGS = -ffunction-sections -fdata-sections -Wl,--gc-sections
+
+#CFLAGS = -Wall -g -O3 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 \
+
+CFLAGS = -Wall -g -Os -D_GNU_SOURCE $(EXTRACFLAGS) -D_FILE_OFFSET_BITS=64 \
+	-ffunction-sections -fdata-sections \
+	-I$(TOP)/ffmpeg/libavutil -I$(TOP)/ffmpeg/libavcodec -I$(TOP)/ffmpeg/libavformat \
+	-I$(TOP)/ffmpeg/libswscale -I$(TOP)/ffmpeg \
+	-I$(TOP)/flac/include -I$(TOP)/sqlite -I$(TOP)/jpeg \
+	-I$(TOP)/libexif -I$(TOP)/libid3tag -I$(TOP)/libogg/include \
+	-I$(TOP)/libvorbis/include \
+
+ifneq ($(STATIC),1)
+LDFLAGS += -L$(TOP)/zlib -L$(TOP)/sqlite/.libs -L$(TOP)/jpeg -L$(TOP)/libvorbis/lib/.libs \
+	-L$(TOP)/libogg/src/.libs -L$(TOP)/libexif/libexif/.libs -L$(TOP)/flac/src/libFLAC/.libs \
+	-L$(TOP)/ffmpeg/libavutil -L$(TOP)/ffmpeg/libavcodec -L$(TOP)/ffmpeg/libavformat \
+	-L$(TOP)/libid3tag/.libs
+LDFLAGS += -static
+endif
+
+#STATIC_LINKING: CFLAGS += -DSTATIC
+#STATIC_LINKING: LDFLAGS = -static
+#CC = gcc
+RM = rm -f
+INSTALL = install
+
+CFLAGS += -I$(TOP)/shared
+
+INSTALLPREFIX ?= $(DESTDIR)/usr
+SBININSTALLDIR = $(INSTALLPREFIX)/sbin
+ETCINSTALLDIR = $(DESTDIR)/etc
+
+BASEOBJS = minidlna.o upnphttp.o upnpdescgen.o upnpsoap.o \
+	   upnpreplyparse.o minixml.o \
+	   getifaddr.o process.o upnpglobalvars.o \
+	   options.o minissdp.o uuid.o upnpevents.o \
+	   sql.o utils.o metadata.o scanner.o monitor.o \
+	   tivo_utils.o tivo_beacon.o tivo_commands.o \
+	   containers.o tagutils/tagutils.o \
+	   playlist.o image_utils.o albumart.o log.o clients.o
+
+ALLOBJS = $(BASEOBJS) $(LNXOBJS)
+
+#LIBS = -lpthread -lexif -ljpeg -lsqlite3 -lavformat -lavutil -lavcodec -lid3tag -lFLAC -logg -lvorbis
+#STATIC_LINKING: LIBS = -lvorbis -logg -lm -lsqlite3 -lpthread -lexif -ljpeg -lFLAC -lm -lid3tag -lz -lavformat -lavutil -lavcodec -lm
+
+ifeq ($(STATIC),1)
+LIBS = -lpthread -lm \
+	$(TOP)/libvorbis/lib/.libs/libvorbis.a \
+	$(TOP)/libogg/src/.libs/libogg.a \
+	$(TOP)/sqlite/.libs/libsqlite3.a \
+	$(TOP)/libexif/libexif/.libs/libexif.a \
+	$(TOP)/jpeg/libjpeg.a \
+	$(TOP)/flac/src/libFLAC/.libs/libFLAC.a \
+	$(TOP)/libid3tag/.libs/libid3tag.a \
+	$(TOP)/zlib/libz.a \
+	$(TOP)/ffmpeg/libavformat/libavformat.a \
+	$(TOP)/ffmpeg/libavcodec/libavcodec.a \
+	$(TOP)/ffmpeg/libavutil/libavutil.a
+else
+LIBS += -lpthread -lm -lvorbis -logg -lsqlite3 -lexif -ljpeg -lFLAC -lid3tag -lz -lavformat -lavcodec -lavutil
+endif
+
+TESTUPNPDESCGENOBJS = testupnpdescgen.o upnpdescgen.o
+
+EXECUTABLES = minidlna testupnpdescgen
+
+.PHONY:	all clean distclean install depend
+
+all:	$(EXECUTABLES)
+
+clean:
+	$(RM) $(ALLOBJS)
+	$(RM) $(EXECUTABLES)
+	$(RM) testupnpdescgen.o
+
+distclean: clean
+#	$(RM) config.h
+
+install-conf:
+	$(INSTALL) -d $(ETCINSTALLDIR)
+	$(INSTALL) --mode=0644 minidlna.conf $(ETCINSTALLDIR)
+
+install:	minidlna
+	$(INSTALL) -D minidlna $(INSTALLDIR)/usr/sbin/minidlna
+	$(STRIP) $(INSTALLDIR)/usr/sbin/minidlna
+
+minidlna:	$(BASEOBJS) $(LNXOBJS)
+	@echo Linking $@
+	@$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(BASEOBJS) $(LNXOBJS) $(LIBS)
+
+
+testupnpdescgen:	$(TESTUPNPDESCGENOBJS)
+	@echo Linking $@
+	@$(CC) $(CFLAGS) -o $@ $(TESTUPNPDESCGENOBJS)
+
+depend:	#config.h
+	makedepend -f$(MAKEFILE_LIST) -Y \
+	$(ALLOBJS:.o=.c) $(TESTUPNPDESCGENOBJS:.o=.c) 2>/dev/null
+
+# DO NOT DELETE
+
+minidlna.o: config.h upnpglobalvars.h minidlnatypes.h
+minidlna.o: upnphttp.h upnpdescgen.h minidlnapath.h getifaddr.h upnpsoap.h
+minidlna.o: options.h minissdp.h process.h upnpevents.h log.h
+upnphttp.o: config.h upnphttp.h upnpdescgen.h minidlnapath.h upnpsoap.h
+upnphttp.o: upnpevents.h image_utils.h sql.h log.h sendfile.h icons.c
+upnpdescgen.o: config.h upnpdescgen.h minidlnapath.h upnpglobalvars.h upnpdescstrings.h
+upnpdescgen.o: minidlnatypes.h upnpdescstrings.h log.h
+containers.o: containers.h
+upnpsoap.o: containers.h config.h upnpglobalvars.h minidlnatypes.h log.h utils.h sql.h
+upnpsoap.o: upnphttp.h upnpsoap.h upnpreplyparse.h getifaddr.h log.h
+upnpreplyparse.o: upnpreplyparse.h minixml.h log.h
+minixml.o: minixml.h
+getifaddr.o: getifaddr.h log.h
+process.o: process.h config.h log.h
+upnpglobalvars.o: config.h upnpglobalvars.h upnpdescstrings.h
+upnpglobalvars.o: minidlnatypes.h
+options.o: options.h config.h upnpglobalvars.h
+options.o: minidlnatypes.h
+minissdp.o: config.h upnpdescstrings.h minidlnapath.h upnphttp.h
+minissdp.o: upnpglobalvars.h minidlnatypes.h minissdp.h log.h
+upnpevents.o: config.h upnpevents.h minidlnapath.h upnpglobalvars.h
+upnpevents.o: minidlnatypes.h upnpdescgen.h log.h uuid.h
+uuid.o: uuid.h
+testupnpdescgen.o: config.h upnpdescgen.h
+scanner.o: upnpglobalvars.h metadata.h utils.h sql.h scanner.h log.h playlist.h scanner_sqlite.h
+metadata.o: upnpglobalvars.h metadata.h albumart.h utils.h sql.h log.h
+albumart.o: upnpglobalvars.h albumart.h utils.h image_utils.h sql.h log.h
+tagutils/tagutils.o: tagutils/tagutils-asf.c tagutils/tagutils-flc.c tagutils/tagutils-plist.c tagutils/tagutils-misc.c
+tagutils/tagutils.o: tagutils/tagutils-aac.c tagutils/tagutils-asf.h tagutils/tagutils-flc.h tagutils/tagutils-mp3.c tagutils/tagutils-wav.c
+tagutils/tagutils.o: tagutils/tagutils-ogg.c tagutils/tagutils-aac.h tagutils/tagutils.h tagutils/tagutils-mp3.h tagutils/tagutils-ogg.h log.h
+playlist.o: playlist.h
+monitor.o: monitor.h playlist.h
+image_utils.o: image_utils.h
+tivo_utils.o: config.h tivo_utils.h
+tivo_beacon.o: config.h tivo_beacon.h tivo_utils.h
+tivo_commands.o: config.h tivo_commands.h tivo_utils.h utils.h
+utils.o: utils.h
+sql.o: sql.h
+log.o: log.h
+clients.o: clients.h
+
+.SUFFIXES: .c .o
+
+.c.o:
+	@echo Compiling $*.c
+	@$(CC) $(CFLAGS) -o $@ -c $< && exit 0;\
+		echo "The following command failed:" 1>&2;\
+		echo "$(CC) $(CFLAGS) -o $@ -c $<";\
+		$(CC) $(CFLAGS) -o $@ -c $< &>/dev/null
--- minidlna/metadata.c	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/metadata.c	2017-09-27 13:41:09.000000000 -0300
@@ -345,6 +345,16 @@ GetAudioMetadata(const char *path, const
 		strcpy(type, "pcm");
 		m.mime = strdup("audio/L16");
 	}
+	else if( ends_with(path, ".dsf") )
+	{
+		strcpy(type, "dsf");
+		m.mime = strdup("audio/x-dsd");
+	}
+	else if( ends_with(path, ".dff") )
+	{
+		strcpy(type, "dff");
+		m.mime = strdup("audio/x-dsd");
+	}
 	else
 	{
 		DPRINTF(E_WARN, L_METADATA, "Unhandled file extension on %s\n", path);
--- minidlna/minidlna.c	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/minidlna.c	2017-09-27 13:41:09.000000000 -0300
@@ -287,7 +287,9 @@ open_db(sqlite3 **sq3)
 	sql_exec(db, "pragma page_size = 4096");
 	sql_exec(db, "pragma journal_mode = OFF");
 	sql_exec(db, "pragma synchronous = OFF;");
-	sql_exec(db, "pragma default_cache_size = 8192;");
+	// this sets the sqlite database cache size
+	// original code had 8192 = 32MB - reduce it to 4MB
+	sql_exec(db, "pragma default_cache_size = 1024;");
 
 	return new_db;
 }
@@ -892,7 +894,7 @@ init(int argc, char **argv)
 		}
 	}
 
-	if (runtime_vars.port <= 0)
+	if (runtime_vars.port < 0)
 	{
 		printf("Usage:\n\t"
 			"%s [-d] [-v] [-f config_file] [-p port]\n"
@@ -951,6 +953,7 @@ init(int argc, char **argv)
 		if (access(db_path, F_OK) != 0)
 			make_dir(db_path, S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO);
 		snprintf(buf, sizeof(buf), "%s/minidlna.log", log_path);
+		unlink("/var/notice/dlna");
 		path = buf;
 		#endif
 	}
@@ -1083,9 +1086,21 @@ main(int argc, char **argv)
 			DPRINTF(E_FATAL, L_GENERAL, "Failed to connect to MiniSSDPd. EXITING");
 	}
 	/* open socket for HTTP connections. */
-	shttpl = OpenAndConfHTTPSocket(runtime_vars.port);
+	shttpl = OpenAndConfHTTPSocket((runtime_vars.port > 0) ? runtime_vars.port : 0);
 	if (shttpl < 0)
 		DPRINTF(E_FATAL, L_GENERAL, "Failed to open socket for HTTP. EXITING\n");
+
+	if(runtime_vars.port <= 0)
+	{
+		struct sockaddr_in sockinfo;
+		socklen_t len = sizeof(struct sockaddr_in);
+		if (getsockname(shttpl, (struct sockaddr *)&sockinfo, &len) < 0)
+		{
+			DPRINTF(E_FATAL, L_GENERAL, "getsockname(): %s. EXITING\n", strerror(errno));
+		}
+		runtime_vars.port = ntohs(sockinfo.sin_port);
+	}
+
 	DPRINTF(E_WARN, L_GENERAL, "HTTP listening on port %d\n", runtime_vars.port);
 
 #ifdef TIVO_SUPPORT
--- minidlna/monitor.c	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/monitor.c	2017-09-27 13:41:09.000000000 -0300
@@ -685,7 +685,12 @@ start_inotify(void)
 				{
 					DPRINTF(E_DEBUG, L_INOTIFY,  "The directory %s was %s.\n",
 						path_buf, (event->mask & IN_MOVED_TO ? "moved here" : "created"));
-					monitor_insert_directory(pollfds[0].fd, esc_name, path_buf);
+						// Tomato
+						begin_scan();
+						sleep(5);
+						if ( wait_for_mount(path_buf) >= 0 )
+							monitor_insert_directory(pollfds[0].fd, esc_name, path_buf);
+						end_scan();
 				}
 				else if ( (event->mask & (IN_CLOSE_WRITE|IN_MOVED_TO|IN_CREATE)) &&
 				          (lstat(path_buf, &st) == 0) )
--- minidlna/scanner.c	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/scanner.c	2017-09-27 13:41:09.000000000 -0300
@@ -27,6 +27,7 @@
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <sys/resource.h>
+#include <sys/statfs.h>
 
 #include "config.h"
 
@@ -66,6 +67,40 @@ struct virtual_item
 	char name[256];
 };
 
+// Tomato
+static int
+is_external_path(const char * path)
+{
+	struct statfs sf;
+
+	if (statfs(path, &sf) == 0)
+	{
+		/* if it returns squashfs or tmpfs type, assume it's not mounted */
+		return (sf.f_type != 0x73717368 && sf.f_type != 0x1021994);
+	}
+	else
+	{
+		return -1;
+	}
+}
+
+/* This could be a directory in tmpfs.
+ * Mounting a USB drive on this directory can take some time,
+ * so let's wait up to 5 seconds and hope that mount will complete.
+ * If not, just proceed with scanning - after all we may not mount
+ * anything on this directory.
+ */
+int
+wait_for_mount(const char * path)
+{
+	int r, n = 50;
+	while ( ((r = is_external_path(path)) == 0) && (n-- > 0) )
+	{
+		usleep(100 * 1000);
+	}
+	return r;
+}
+
 int64_t
 get_next_available_id(const char *table, const char *parentID)
 {
@@ -907,6 +942,8 @@ start_scanner(void)
 	if( GETFLAG(RESCAN_MASK) )
 		return start_rescan();
 
+	begin_scan(); // Tomato
+	//_notify_start();
 	for( media_path = media_dirs; media_path != NULL; media_path = media_path->next )
 	{
 		int64_t id;
@@ -929,6 +966,9 @@ start_scanner(void)
 		ScanDirectory(media_path->path, parent, media_path->types);
 		sql_exec(db, "INSERT into SETTINGS values (%Q, %Q)", "media_dir", media_path->path);
 	}
+	//_notify_stop();
+	end_scan(); // Tomato
+
 	/* Create this index after scanning, so it doesn't slow down the scanning process.
 	 * This index is very useful for large libraries used with an XBox360 (or any
 	 * client that uses UPnPSearch on large containers). */
--- minidlna/scanner.h	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/scanner.h	2017-09-27 13:41:09.000000000 -0300
@@ -83,4 +83,7 @@ CreateDatabase(void);
 void
 start_scanner();
 
+int
+wait_for_mount(const char * path);     // Tomato
+
 #endif
--- minidlna/tagutils/tagutils.c	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/tagutils/tagutils.c	2017-09-06 01:28:18.000000000 -0300
@@ -111,6 +111,8 @@ char *winamp_genre[] = {
 #include "tagutils-asf.h"
 #include "tagutils-wav.h"
 #include "tagutils-pcm.h"
+#include "tagutils-dsf.h"
+#include "tagutils-dff.h"
 
 static int _get_tags(char *file, struct song_metadata *psong);
 static int _get_fileinfo(char *file, struct song_metadata *psong);
@@ -136,6 +138,8 @@ static taghandler taghandlers[] = {
 	{ "asf", 0,            _get_asffileinfo                                  },
 	{ "wav", _get_wavtags, _get_wavfileinfo                                  },
 	{ "pcm", 0,            _get_pcmfileinfo                                  },
+	{ "dsf", _get_dsftags, _get_dsffileinfo                                  },
+	{ "dff", 0,            _get_dfffileinfo                                  },
 	{ NULL,  0 }
 };
 
@@ -153,6 +157,8 @@ static taghandler taghandlers[] = {
 #include "tagutils-wav.c"
 #include "tagutils-pcm.c"
 #include "tagutils-plist.c"
+#include "tagutils-dsf.c"
+#include "tagutils-dff.c"
 
 //*********************************************************************************
 // freetags()
--- minidlna/tagutils/tagutils-dff.c	1969-12-31 21:00:00.000000000 -0300
+++ minidlna/tagutils/tagutils-dff.c	2017-09-06 01:28:18.000000000 -0300
@@ -0,0 +1,393 @@
+//=========================================================================
+// FILENAME     : tagutils-dff.c
+// DESCRIPTION  : DFF metadata reader
+//=========================================================================
+// Copyright (c) 2014 Takeshich NAKAMURA
+//=========================================================================
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+#define GET_DFF_INT64(p) ((((uint64_t)((p)[0])) << 56) |   \
+                          (((uint64_t)((p)[1])) << 48) |   \
+                          (((uint64_t)((p)[2])) << 40) |   \
+                          (((uint64_t)((p)[3])) << 32) |   \
+                          (((uint64_t)((p)[4])) << 24) |   \
+                          (((uint64_t)((p)[5])) << 16) |   \
+                          (((uint64_t)((p)[6])) << 8) |    \
+                          (((uint64_t)((p)[7])) ))
+
+#define GET_DFF_INT32(p) ((((uint32_t)((p)[0])) << 24) |   \
+                          (((uint32_t)((p)[1])) << 16) |   \
+                          (((uint32_t)((p)[2])) << 8) |     \
+                          (((uint32_t)((p)[3])) ))
+
+#define GET_DFF_INT16(p) ((((uint16_t)((p)[0])) << 8) |   \
+                          (((uint16_t)((p)[1])) )) 
+
+static int
+_get_dfffileinfo(char *file, struct song_metadata *psong)
+{
+	FILE *fp;
+	uint32_t len;
+	uint32_t rt;
+	unsigned char hdr[32] = {0};
+
+	uint64_t totalsize = 0;
+	uint64_t propckDataSize = 0;
+	uint64_t count = 0;
+	uint32_t samplerate = 0;
+	uint16_t channels = 0;
+	//DST
+	uint64_t dstickDataSize = 0;
+	uint32_t numFrames = 0;
+	uint16_t frameRate = 0;
+	unsigned char frteckData[18] = {0};
+	unsigned char dstickData[12] = {0};
+	uint64_t totalcount = 0;
+	unsigned char ckbuf[12] = {0};
+	unsigned char compressionType[4] = {0};
+	unsigned char dsdsdckData[12] = {0};
+	uint64_t dsdsdckDataSize = 0;
+	uint64_t cmprckDataSize = 0;
+	uint64_t abssckDataSize = 0;
+	uint64_t lscockDataSize = 0;
+	uint64_t comtckDataSize = 0;
+	uint64_t diinckDataSize = 0;
+	uint64_t diarckDataSize = 0;
+	uint64_t ditickDataSize = 0;
+	uint64_t manfckDataSize = 0;
+
+	//DPRINTF(E_DEBUG,L_SCANNER,"Getting DFF fileinfo =%s\n",file);    
+	
+	if((fp = fopen(file, "rb")) == NULL)
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Could not create file handle\n");
+		return -1;
+	}
+		
+	len = 32;
+	//Form DSD chunk
+	if(!(rt = fread(hdr, len, 1,fp)))
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Could not read Form DSD chunk from %s\n", file);
+		fclose(fp);
+ 		return -1;
+	}
+	
+	if(strncmp((char*)hdr, "FRM8", 4))
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Invalid Form DSD chunk in %s\n", file);
+		fclose(fp);
+		return -1;
+	}
+        
+	totalsize = GET_DFF_INT64(hdr + 4) ;
+       
+	if(strncmp((char*)hdr+12, "DSD ", 4))
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Invalid Form DSD chunk in %s\n", file);
+		fclose(fp);
+		return -1;
+	}
+
+	//FVER chunk
+	if(strncmp((char*)hdr+16, "FVER", 4))
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Invalid Format Version Chunk in %s\n", file);
+		fclose(fp);
+		return -1;
+	}
+
+	totalsize -= 16;
+	while(totalcount < totalsize - 4)
+	{
+	
+		if(!(rt = fread(ckbuf, sizeof(ckbuf), 1,fp)))
+		{
+			//DPRINTF(E_WARN, L_SCANNER, "Could not read chunk header from %s\n", file);
+			//fclose(fp);
+ 			//return -1;
+			break;
+		}
+	
+		//Property chunk
+		if(strncmp((char*)ckbuf, "PROP", 4) == 0)
+ 		{
+
+			
+			propckDataSize = GET_DFF_INT64(ckbuf + 4);
+			totalcount += propckDataSize + 12;
+
+			unsigned char propckData[propckDataSize];
+
+			if(!(rt = fread(propckData, propckDataSize, 1,fp)))
+			{
+				DPRINTF(E_WARN, L_SCANNER, "Could not read Property chunk from %s\n", file);
+				fclose(fp);
+				return -1;
+			}
+				
+			if(strncmp((char*)propckData, "SND ", 4))
+ 			{
+ 				DPRINTF(E_WARN, L_SCANNER, "Invalid Property chunk in %s\n", file);
+ 				fclose(fp);
+ 				return -1;
+ 			}
+
+			count += 4;	
+			while(count < propckDataSize)
+			{
+				if(strncmp((char*)propckData+count, "FS  ", 4) == 0)
+				{
+					//Sample Rate Chunk
+					count += 12;
+					samplerate = GET_DFF_INT32(propckData+count);
+					psong->samplerate = samplerate;
+					count += 4;
+					
+					//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "Sample Rate is %d\n", psong->samplerate);
+				}else if(strncmp((char*)propckData+count, "CHNL", 4) == 0)
+				{
+					//Channels Chunk
+					count += 12;
+					channels = GET_DFF_INT16(propckData+count);
+					psong->channels = channels;
+					count += channels * 4 + 2;
+					
+					//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "channels is %d\n", channels);
+				}else if(strncmp((char*)propckData+count, "CMPR", 4) == 0)
+				{
+					//Compression Type Chunk
+					count += 4;
+					cmprckDataSize = GET_DFF_INT64(propckData+count);
+					count += 8;
+					strncpy((char*)compressionType,(char*)propckData+count,4);
+					count += cmprckDataSize;
+					
+				}else if(strncmp((char*)propckData+count, "ABSS", 4) == 0)
+				{
+					//Absolute Start Time Chunk
+					count += 4;
+					abssckDataSize = GET_DFF_INT64(propckData+count);
+					count += abssckDataSize + 8;
+					
+				}else if(strncmp((char*)propckData+count, "LSCO", 4) == 0)
+				{
+					//Loudsperaker Configuration Chunk
+					count += 4;
+					lscockDataSize = GET_DFF_INT64(propckData+count);
+					count += lscockDataSize + 8;
+					
+				}else{
+					break;
+				}
+			}
+
+			//bitrate bitpersample is 1bit
+			psong->bitrate = channels * samplerate * 1;
+
+			//DSD/DST Sound Data Chunk
+			len = 12;
+			if(!(rt = fread(dsdsdckData, len, 1,fp)))
+			{
+				DPRINTF(E_WARN, L_SCANNER, "Could not read DSD/DST Sound Data chunk from %s\n", file);
+				fclose(fp);
+				return -1;
+			}
+	
+			if(strncmp((char*)compressionType,(char*)dsdsdckData , 4))
+			{
+				DPRINTF(E_WARN, L_SCANNER, "Invalid DSD/DST Sound Data chunk in %s\n", file);
+				fclose(fp);
+				return -1;
+			}
+
+			if(strncmp((char*)dsdsdckData,"DSD " , 4) == 0)
+			{
+				//DSD
+				dsdsdckDataSize = GET_DFF_INT64(dsdsdckData+4);
+				totalcount += dsdsdckDataSize + 12;
+				psong->song_length = (int)((double)dsdsdckDataSize / (double)samplerate / (double)channels * 8 * 1000);
+				
+				//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "songlength is %d\n", psong->song_length);
+				
+				fseeko(fp, dsdsdckDataSize,SEEK_CUR);
+			}else if(strncmp((char*)dsdsdckData,"DST " , 4) == 0)
+			{
+				//DST
+				dsdsdckDataSize = GET_DFF_INT64(dsdsdckData+4);
+				totalcount += dsdsdckDataSize + 12;
+	
+				//DST Frame Information chunk	
+				if(!(rt = fread(frteckData, 18, 1,fp)))
+				{
+					DPRINTF(E_WARN, L_SCANNER, "Could not read DST Frame Information chunk from %s\n", file);
+					fclose(fp);
+					return -1;
+				}
+
+				if(strncmp((char*)frteckData ,"FRTE", 4) == 0)
+				{
+					//uint64_t frteckDataSize = GET_DFF_INT64(frteckData+4);
+					numFrames = GET_DFF_INT32((char*)frteckData+12);
+					frameRate = GET_DFF_INT16((char*)frteckData+16);
+
+					psong->song_length = numFrames / frameRate * 1000;
+	
+					fseeko(fp, dsdsdckDataSize-18,SEEK_CUR); 
+				}else
+				{
+					DPRINTF(E_WARN, L_SCANNER, "Invalid DST Frame Information chunk in %s\n", file);
+					fclose(fp);
+					return -1;
+				}
+
+				//DST Sound Index Chunk
+				if(!(rt = fread(dstickData, 12, 1,fp)))
+				{
+					if (ferror(fp))
+					{
+						DPRINTF(E_WARN, L_SCANNER, "Could not read DST Sound Index chunk from %s\n", file);
+						fclose(fp);
+						return -1;
+					}else
+					{
+						//EOF
+						break;
+					}
+				}
+
+				if(strncmp((char*)dstickData ,"DSTI", 4) == 0)
+				{
+					dstickDataSize = GET_DFF_INT64(dstickData+4);
+					totalcount += dstickDataSize + 12;
+					fseeko(fp, dstickDataSize,SEEK_CUR);
+				}else
+				{
+					fseeko(fp, -12,SEEK_CUR);
+				}
+			}else
+			{
+				DPRINTF(E_WARN, L_SCANNER, "Invalid DSD/DST Sound Data chunk in %s\n", file);
+				fclose(fp);
+				return -1;
+			}
+		}else if(!strncmp((char*)ckbuf ,"COMT", 4))
+		{
+			//COMT Chunk
+			comtckDataSize = GET_DFF_INT64(ckbuf+4);
+			totalcount += comtckDataSize + 12;
+			fseeko(fp, comtckDataSize,SEEK_CUR);
+
+		}else if(!strncmp((char*)ckbuf ,"DIIN", 4))
+		{
+			//Edited Master Information chunk
+			diinckDataSize = GET_DFF_INT64(ckbuf+4);
+			unsigned char diinckData[diinckDataSize];
+			totalcount += diinckDataSize + 12;
+			
+			if(!(rt = fread(diinckData, diinckDataSize, 1,fp)))
+			{
+				DPRINTF(E_WARN, L_SCANNER, "Could not read Edited Master Information chunk from %s\n", file);
+				fclose(fp);
+				return -1;
+			}
+
+			uint64_t icount = 0;
+			while(icount < diinckDataSize)
+			{
+				if(!strncmp((char*)diinckData+icount ,"EMID", 4))
+				{
+					//Edited Master ID chunk
+					icount += 4;	
+					icount += GET_DFF_INT64(diinckData+icount) + 8;
+
+				}else if(!strncmp((char*)diinckData+icount ,"MARK", 4))
+				{
+					//Master Chunk
+					icount += 4;	
+					icount += GET_DFF_INT64(diinckData+icount) + 8;
+
+				}else if(!strncmp((char*)diinckData+icount ,"DIAR", 4))
+				{
+					//Artist Chunk
+					icount += 4;
+					diarckDataSize = GET_DFF_INT64(diinckData+icount);
+					unsigned char arttext[diarckDataSize +1 - 4];
+					
+					icount += 12;	
+					
+					memset(arttext,0x00,sizeof(arttext));	
+					strncpy((char*)arttext,(char*)diinckData+icount,sizeof(arttext)-1);
+					psong->contributor[ROLE_ARTIST] = strdup((char*)&arttext[0]);
+
+					icount += diarckDataSize - 4;
+					
+				}else if(!strncmp((char*)diinckData+icount ,"DITI", 4))
+				{
+					//Title Chunk
+					icount += 4;
+					ditickDataSize = GET_DFF_INT64(diinckData+icount);
+					unsigned char titletext[ditickDataSize+1 - 4];
+					
+					icount += 12;
+					
+					memset(titletext,0x00,sizeof(titletext));	
+					strncpy((char*)titletext,(char*)diinckData+icount,sizeof(titletext)-1);
+					psong->title =  strdup((char*)&titletext[0]);
+					icount += ditickDataSize - 4;
+					
+				}else
+				{
+					break;
+				}
+			}
+		}else if(!strncmp((char*)ckbuf ,"MANF", 4))
+		{
+			//Manufacturer Specific Chunk
+			manfckDataSize = GET_DFF_INT64(ckbuf+4);
+			totalcount += manfckDataSize + 12;
+			fseeko(fp, manfckDataSize,SEEK_CUR);
+
+		}
+	}
+	
+	fclose(fp);
+
+	//DPRINTF(E_DEBUG, L_SCANNER, "totalsize is 0x%016lx\n", (long unsigned int)totalsize);
+	//DPRINTF(E_DEBUG, L_SCANNER, "propckDataSize is 0x%016lx\n", (long unsigned int)propckDataSize);
+	//DPRINTF(E_DEBUG, L_SCANNER, "cmprckDataSize is 0x%016lx\n", (long unsigned int)cmprckDataSize);
+	//DPRINTF(E_DEBUG, L_SCANNER, "abssckDataSize is 0x%016lx\n", (long unsigned int)abssckDataSize);
+	//DPRINTF(E_DEBUG, L_SCANNER, "lscockDataSize is 0x%016lx\n", (long unsigned int)lscockDataSize);
+	//DPRINTF(E_DEBUG, L_SCANNER, "dsdsdckDataSize is 0x%016lx\n", (long unsigned int)dsdsdckDataSize);
+	//DPRINTF(E_DEBUG, L_SCANNER, "dstickDataSize is 0x%016lx\n", (long unsigned int)dstickDataSize);
+	//DPRINTF(E_DEBUG, L_SCANNER, "comtckDataSize is 0x%016lx\n", (long unsigned int)comtckDataSize);
+	//DPRINTF(E_DEBUG, L_SCANNER, "diinckDataSize is 0x%016lx\n", (long unsigned int)diinckDataSize);
+	//DPRINTF(E_DEBUG, L_SCANNER, "diarckDataSize is 0x%016lx\n", (long unsigned int)diarckDataSize);
+	//DPRINTF(E_DEBUG, L_SCANNER, "ditickDataSize is 0x%016lx\n", (long unsigned int)ditickDataSize);
+	//DPRINTF(E_DEBUG, L_SCANNER, "manfckDataSize is 0x%016lx\n", (long unsigned int)manfckDataSize);
+	
+
+	//DPRINTF(E_DEBUG, L_SCANNER, "Got dff fileinfo successfully=%s\n", file);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "TITLE is %s\n",psong->title );
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "ARTIST is %s\n",psong->contributor[ROLE_ARTIST]);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "samplerate is  %d\n", psong->samplerate);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "song_length is  %d\n", psong->song_length);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "channels are  %d\n", psong->channels);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "bitrate is  %d\n", psong->bitrate);
+
+    xasprintf(&(psong->dlna_pn), "DFF");
+    return 0;
+}
--- minidlna/tagutils/tagutils-dff.h	1969-12-31 21:00:00.000000000 -0300
+++ minidlna/tagutils/tagutils-dff.h	2017-09-06 01:28:18.000000000 -0300
@@ -0,0 +1,22 @@
+//=========================================================================
+// FILENAME     : tagutils-dff.h
+// DESCRIPTION  : DFF metadata reader
+//=========================================================================
+// Copyright (c) 2014 Takeshich NAKAMURA
+//=========================================================================
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+static int _get_dfffileinfo(char *file, struct song_metadata *psong);
--- minidlna/tagutils/tagutils-dsf.c	1969-12-31 21:00:00.000000000 -0300
+++ minidlna/tagutils/tagutils-dsf.c	2017-09-06 01:28:18.000000000 -0300
@@ -0,0 +1,426 @@
+//=========================================================================
+// FILENAME	: tagutils-dsf.c
+// DESCRIPTION	: DSF metadata reader
+//=========================================================================
+// Copyright (c) 2014 Takeshich NAKAMURA 
+// based on tagutils-mp3.c
+//=========================================================================
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define GET_DSF_INT64(p) ((((uint64_t)((p)[7])) << 56) |   \
+			  (((uint64_t)((p)[6])) << 48) |   \
+			  (((uint64_t)((p)[5])) << 40) |   \
+			  (((uint64_t)((p)[4])) << 32) |   \
+		  	  (((uint64_t)((p)[3])) << 24) |   \
+			  (((uint64_t)((p)[2])) << 16) |   \
+			  (((uint64_t)((p)[1])) << 8) |	   \
+			  (((uint64_t)((p)[0]))))
+
+#define GET_DSF_INT32(p) ((((uint8_t)((p)[3])) << 24) |   \
+			  (((uint8_t)((p)[2])) << 16) |   \
+			  (((uint8_t)((p)[1])) << 8) |	   \
+			  (((uint8_t)((p)[0]))))
+			
+static int
+_get_dsftags(char *file, struct song_metadata *psong)
+{
+	struct id3_tag *pid3tag;
+	struct id3_frame *pid3frame;
+	int err;
+	int index;
+	int used;
+	unsigned char *utf8_text;
+	int genre = WINAMP_GENRE_UNKNOWN;
+	int have_utf8;
+	int have_text;
+	id3_ucs4_t const *native_text;
+	char *tmp;
+	int got_numeric_genre;
+	id3_byte_t const *image;
+	id3_length_t image_size = 0;
+	
+	FILE *fp;
+	struct id3header *pid3;
+	uint32_t len;
+	unsigned char hdr[28] = {0};
+	uint64_t total_size = 0;
+	uint64_t pointer_to_metadata_chunk = 0;
+	uint64_t metadata_chunk_size = 0;
+	unsigned char *id3tagbuf = NULL;
+
+	//DEBUG DPRINTF(E_DEBUG,L_SCANNER,"Getting DSF file info\n");
+
+	if((fp = fopen(file, "rb")) == NULL)
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Could not create file handle\n");
+		return -1;
+	}
+
+	len = 28;
+	if(!(len = fread(hdr, len, 1,fp)))
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Could not read DSD Chunk from %s\n", file);
+		fclose(fp);
+		return -1;
+	}
+
+	if(strncmp((char*)hdr, "DSD ", 4))
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Invalid DSD Chunk header in %s\n", file);
+		fclose(fp);
+		return -1;
+	}
+
+	total_size = GET_DSF_INT64(hdr + 12);
+	pointer_to_metadata_chunk = GET_DSF_INT64(hdr + 20);
+	
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "%llu\n", total_size);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "%llu\n", pointer_to_metadata_chunk);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "%llu\n", metadata_chunk_size);
+
+	//check invalid metadata
+	if(total_size == 0)
+	{
+		fclose(fp);
+		DPRINTF(E_INFO, L_SCANNER, "Invalid TotalDataSize in %s\n", file);
+		return 0;
+	}
+
+	if(pointer_to_metadata_chunk == 0)
+	{
+		fclose(fp);
+		DPRINTF(E_INFO, L_SCANNER, "Metadata doesn't exist %s\n", file);
+		return 0;
+	}
+
+	if(total_size > pointer_to_metadata_chunk)
+	{
+		metadata_chunk_size = total_size - pointer_to_metadata_chunk;
+	}
+	else
+	{
+		fclose(fp);
+		DPRINTF(E_INFO, L_SCANNER, "Invalid PointerToMetadata in %s\n", file);
+		return 0;
+	}
+
+	fseeko(fp, pointer_to_metadata_chunk,SEEK_SET);
+
+	id3tagbuf = (unsigned char *)malloc(sizeof(unsigned char)*metadata_chunk_size);
+	if(id3tagbuf == NULL)
+	{
+		fclose(fp);
+		DPRINTF(E_WARN, L_SCANNER, "Out of memory.Big MetadataSize in %s\n",file);
+		return -1;
+	}
+	memset(id3tagbuf, 0,sizeof(unsigned char)*metadata_chunk_size);
+	
+	if(!(len = fread(id3tagbuf,metadata_chunk_size,1,fp)))
+	{
+		fclose(fp);
+		free(id3tagbuf);
+		DPRINTF(E_WARN, L_SCANNER, "Could not read Metadata Chunk from %s\n", file);
+		return -1;
+	}
+	
+	pid3tag = id3_tag_parse(id3tagbuf,metadata_chunk_size);
+	
+	if(!pid3tag)
+	{
+		free(id3tagbuf);
+		err = errno;
+		errno = err;
+		DPRINTF(E_WARN, L_SCANNER, "Cannot get ID3 tag for %s\n", file);
+		return -1;
+	}
+
+	pid3 = (struct id3header*)id3tagbuf;
+
+	if(strncmp((char*)pid3->id, "ID3", 3) == 0)
+	{
+		char tagversion[16];
+
+		/* found an ID3 header... */
+		snprintf(tagversion, sizeof(tagversion), "ID3v2.%d.%d",
+			 pid3->version[0], pid3->version[1]);
+		psong->tagversion = strdup(tagversion);
+	}
+	pid3 = NULL;
+	
+	index = 0;
+	while((pid3frame = id3_tag_findframe(pid3tag, "", index)))
+	{
+		used = 0;
+		utf8_text = NULL;
+		native_text = NULL;
+		have_utf8 = 0;
+		have_text = 0;
+
+		if(!strcmp(pid3frame->id, "YTCP"))   /* for id3v2.2 */
+		{
+			psong->compilation = 1;
+			DPRINTF(E_DEBUG, L_SCANNER, "Compilation: %d [%s]\n", psong->compilation, basename(file));
+		}
+		else if(!strcmp(pid3frame->id, "APIC") && !image_size)
+		{
+			if( (strcmp((char*)id3_field_getlatin1(&pid3frame->fields[1]), "image/jpeg") == 0) ||
+			    (strcmp((char*)id3_field_getlatin1(&pid3frame->fields[1]), "image/jpg") == 0) ||
+			    (strcmp((char*)id3_field_getlatin1(&pid3frame->fields[1]), "jpeg") == 0) )
+			{
+				image = id3_field_getbinarydata(&pid3frame->fields[4], &image_size);
+				if( image_size )
+				{
+					psong->image = malloc(image_size);
+					memcpy(psong->image, image, image_size);
+					psong->image_size = image_size;
+					//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "Found thumbnail: %d\n", psong->image_size);
+				}
+			}
+		}
+
+		if(((pid3frame->id[0] == 'T') || (strcmp(pid3frame->id, "COMM") == 0)) &&
+		   (id3_field_getnstrings(&pid3frame->fields[1])))
+			have_text = 1;
+
+		if(have_text)
+		{
+			native_text = id3_field_getstrings(&pid3frame->fields[1], 0);
+
+			if(native_text)
+			{
+				have_utf8 = 1;
+				if(lang_index >= 0)
+					utf8_text = _get_utf8_text(native_text); // through iconv
+				else
+					utf8_text = (unsigned char*)id3_ucs4_utf8duplicate(native_text);
+
+				if(!strcmp(pid3frame->id, "TIT2"))
+				{
+					used = 1;
+					psong->title = (char*)utf8_text;
+				}
+				else if(!strcmp(pid3frame->id, "TPE1"))
+				{
+					used = 1;
+					psong->contributor[ROLE_ARTIST] = (char*)utf8_text;
+				}
+				else if(!strcmp(pid3frame->id, "TALB"))
+				{
+					used = 1;
+					psong->album = (char*)utf8_text;
+				}
+				else if(!strcmp(pid3frame->id, "TCOM"))
+				{
+					used = 1;
+					psong->contributor[ROLE_COMPOSER] = (char*)utf8_text;
+				}
+				else if(!strcmp(pid3frame->id, "TIT1"))
+				{
+					used = 1;
+					psong->grouping = (char*)utf8_text;
+				}
+				else if(!strcmp(pid3frame->id, "TPE2"))
+				{
+					used = 1;
+					psong->contributor[ROLE_BAND] = (char*)utf8_text;
+				}
+				else if(!strcmp(pid3frame->id, "TPE3"))
+				{
+					used = 1;
+					psong->contributor[ROLE_CONDUCTOR] = (char*)utf8_text;
+				}
+				else if(!strcmp(pid3frame->id, "TCON"))
+				{
+					used = 1;
+					psong->genre = (char*)utf8_text;
+					got_numeric_genre = 0;
+					if(psong->genre)
+					{
+						if(!strlen(psong->genre))
+						{
+							genre = WINAMP_GENRE_UNKNOWN;
+							got_numeric_genre = 1;
+						}
+						else if(isdigit(psong->genre[0]))
+						{
+							genre = atoi(psong->genre);
+							got_numeric_genre = 1;
+						}
+						else if((psong->genre[0] == '(') && (isdigit(psong->genre[1])))
+						{
+							genre = atoi((char*)&psong->genre[1]);
+							got_numeric_genre = 1;
+						}
+
+						if(got_numeric_genre)
+						{
+							if((genre < 0) || (genre > WINAMP_GENRE_UNKNOWN))
+								genre = WINAMP_GENRE_UNKNOWN;
+							free(psong->genre);
+							psong->genre = strdup(winamp_genre[genre]);
+						}
+					}
+				}
+				else if(!strcmp(pid3frame->id, "COMM"))
+				{
+					used = 1;
+					psong->comment = (char*)utf8_text;
+				}
+				else if(!strcmp(pid3frame->id, "TPOS"))
+				{
+					tmp = (char*)utf8_text;
+					strsep(&tmp, "/");
+					if(tmp)
+					{
+						psong->total_discs = atoi(tmp);
+					}
+					psong->disc = atoi((char*)utf8_text);
+				}
+				else if(!strcmp(pid3frame->id, "TRCK"))
+				{
+					tmp = (char*)utf8_text;
+					strsep(&tmp, "/");
+					if(tmp)
+					{
+						psong->total_tracks = atoi(tmp);
+					}
+					psong->track = atoi((char*)utf8_text);
+				}
+				else if(!strcmp(pid3frame->id, "TDRC"))
+				{
+					psong->year = atoi((char*)utf8_text);
+				}
+				else if(!strcmp(pid3frame->id, "TLEN"))
+				{
+					psong->song_length = atoi((char*)utf8_text);
+				}
+				else if(!strcmp(pid3frame->id, "TBPM"))
+				{
+					psong->bpm = atoi((char*)utf8_text);
+				}
+				else if(!strcmp(pid3frame->id, "TCMP"))
+				{
+					psong->compilation = (char)atoi((char*)utf8_text);
+				}
+			}
+		}
+
+		// check if text tag
+		if((!used) && (have_utf8) && (utf8_text))
+			free(utf8_text);
+
+		// v2 COMM
+		if((!strcmp(pid3frame->id, "COMM")) && (pid3frame->nfields == 4))
+		{
+			native_text = id3_field_getstring(&pid3frame->fields[2]);
+			if(native_text)
+			{
+				utf8_text = (unsigned char*)id3_ucs4_utf8duplicate(native_text);
+				if((utf8_text) && (strncasecmp((char*)utf8_text, "iTun", 4) != 0))
+				{
+					// read comment
+					free(utf8_text);
+
+					native_text = id3_field_getfullstring(&pid3frame->fields[3]);
+					if(native_text)
+					{
+						utf8_text = (unsigned char*)id3_ucs4_utf8duplicate(native_text);
+						if(utf8_text)
+						{
+							free(psong->comment);
+							psong->comment = (char*)utf8_text;
+						}
+					}
+				}
+				else
+				{
+					free(utf8_text);
+				}
+			}
+		}
+
+		index++;
+	}
+
+	id3_tag_delete(pid3tag);
+	free(id3tagbuf);
+	fclose(fp);
+	//DPRINTF(E_DEBUG, L_SCANNER, "Got id3tag successfully for file=%s\n", file);
+	return 0;
+}
+
+static int
+_get_dsffileinfo(char *file, struct song_metadata *psong)
+{
+	FILE *fp;
+	int len = 80;
+	unsigned char hdr[len];
+	uint32_t channelnum;
+	uint32_t samplingfrequency;
+	uint32_t bitpersample;
+	uint64_t samplecount;
+
+	if((fp = fopen(file, "rb")) == NULL)
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Could not create file handle\n");
+		return -1;
+	}
+
+	if(!(len = fread(hdr, len, 1,fp)))
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Could not read chunks from %s\n", file);
+		fclose(fp);
+		return -1;
+	}
+ 
+	if(strncmp((char*)hdr, "DSD ", 4))
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Invalid DSD Chunk headerin %s\n", file);
+		fclose(fp);
+		return -1;
+	}
+
+	if(strncmp((char*)hdr+28, "fmt ", 4))
+	{
+		DPRINTF(E_WARN, L_SCANNER, "Invalid fmt Chunk header in %s\n", file);
+		fclose(fp);
+		return -1;
+	}
+
+	channelnum = GET_DSF_INT32(hdr + 52);
+	samplingfrequency = GET_DSF_INT32(hdr + 56);
+	bitpersample = GET_DSF_INT32(hdr + 60);
+	samplecount = GET_DSF_INT64(hdr + 64);
+
+	psong->bitrate = channelnum * samplingfrequency * bitpersample;
+	psong->samplesize = bitpersample;
+	psong->samplerate = samplingfrequency;
+	psong->song_length = (samplecount / samplingfrequency) * 1000;
+	psong->channels = channelnum;
+
+	//DEBUG DPRINTF(E_INFO, L_SCANNER, "Got fileinfo successfully from =%s\n", file);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "bitrate is  %d\n", psong->bitrate);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "samplesize is  %d\n", psong->samplesize);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "samplerate is  %d\n", psong->samplerate);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "song_length is  %d\n", psong->song_length);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "channels are  %d\n", psong->channels);
+	//DEBUG DPRINTF(E_DEBUG, L_SCANNER, "samplecount are  %lld\n", samplecount);
+	fclose(fp);
+
+	xasprintf(&(psong->dlna_pn), "DSF");
+	return 0;
+}
--- minidlna/tagutils/tagutils-dsf.h	1969-12-31 21:00:00.000000000 -0300
+++ minidlna/tagutils/tagutils-dsf.h	2017-09-06 01:28:18.000000000 -0300
@@ -0,0 +1,23 @@
+//=========================================================================
+// FILENAME	: tagutils-dsf.h
+// DESCRIPTION	: DSF metadata reader
+//=========================================================================
+// Copyright (c) 2014 Takeshich NAKAMURA
+//=========================================================================
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+static int _get_dsffileinfo(char *file, struct song_metadata *psong);
+static int _get_dsftags(char *file, struct song_metadata *psong);
--- minidlna/testupnpdescgen.c	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/testupnpdescgen.c	2017-09-06 01:28:18.000000000 -0300
@@ -31,7 +31,11 @@
 #include <string.h>
 
 #include "config.h"
+#include "getifaddr.h"
 #include "upnpdescgen.h"
+#include "minidlnapath.h"
+#include "upnpglobalvars.h"
+#include "upnpdescstrings.h"
 
 char uuidvalue[] = "uuid:12345678-0000-0000-0000-00000000abcd";
 char friendly_name[] = "localhost: system_type";
--- minidlna/upnpdescgen.c	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/upnpdescgen.c	2017-09-27 09:32:32.000000000 -0300
@@ -35,6 +35,7 @@
 #include "upnpdescgen.h"
 #include "minidlnapath.h"
 #include "upnpglobalvars.h"
+#include "upnpdescstrings.h"
 
 #undef DESC_DEBUG
 
--- minidlna/upnpdescstrings.h	1969-12-31 21:00:00.000000000 -0300
+++ minidlna/upnpdescstrings.h	2017-09-06 01:28:18.000000000 -0300
@@ -0,0 +1,41 @@
+/* miniupnp project
+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/
+ *
+ * Copyright (c) 2006, Thomas Bernard
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * The name of the author may not be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __UPNPDESCSTRINGS_H__
+#define __UPNPDESCSTRINGS_H__
+
+#include "config.h"
+
+/* strings used in the root device xml description */
+#define ROOTDEV_MANUFACTURERURL		"http://tomatousb.org/"
+#define ROOTDEV_MANUFACTURER		"TomatoUSB"
+#define ROOTDEV_MODELNAME		"Windows Media Connect compatible"
+#define ROOTDEV_MODELDESCRIPTION	OS_NAME
+#define ROOTDEV_MODELURL		"http://tomatousb.org/"
+
+#endif
--- minidlna/upnpglobalvars.c	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/upnpglobalvars.c	2017-09-27 13:41:09.000000000 -0300
@@ -53,6 +53,7 @@
 
 #include "config.h"
 #include "upnpglobalvars.h"
+#include "upnpdescstrings.h"
 
 /* startup time */
 time_t startup_time = 0;
--- minidlna/upnpglobalvars.h	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/upnpglobalvars.h	2017-09-27 13:41:09.000000000 -0300
@@ -165,6 +165,7 @@
 	"http-get:*:audio/mp4:*," \
 	"http-get:*:audio/x-wav:*," \
 	"http-get:*:audio/x-flac:*," \
+	"http-get:*:audio/x-dsd:*," \
 	"http-get:*:application/ogg:*"
 
 #define DLNA_FLAG_DLNA_V1_5      0x00100000
--- minidlna/utils.c	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/utils.c	2017-09-27 13:41:09.000000000 -0300
@@ -347,6 +347,8 @@ mime_to_ext(const char * mime)
 				return "3gp";
 			else if( strcmp(mime, "application/ogg") == 0 )
 				return "ogg";
+			else if( strcmp(mime+6, "x-dsd") == 0 )
+				return "dsd";
 			break;
 		case 'v':
 			if( strcmp(mime+6, "avi") == 0 )
@@ -414,7 +416,8 @@ is_audio(const char * file)
 		ends_with(file, ".m4a") || ends_with(file, ".aac")  ||
 		ends_with(file, ".mp4") || ends_with(file, ".m4p")  ||
 		ends_with(file, ".wav") || ends_with(file, ".ogg")  ||
-		ends_with(file, ".pcm") || ends_with(file, ".3gp"));
+		ends_with(file, ".pcm") || ends_with(file, ".3gp")  ||
+		ends_with(file, ".dsf") || ends_with(file, ".dff"));
 }
 
 int
@@ -531,3 +534,35 @@ valid_media_types(const char *path)
 
 	return ALL_MEDIA;
 }
+
+void
+begin_scan()
+{
+	FILE * flag;
+
+#ifdef READYNAS
+	flag = fopen("/ramfs/.upnp-av_scan", "w");
+	if( flag )
+		fclose(flag);
+#else
+	mkdir("/var/notice", 0755);
+	flag = fopen("/var/notice/dlna", "w");
+	if( flag )
+	{
+		fprintf(flag, "Scan in progress");
+		fclose(flag);
+	}
+#endif
+}
+
+void
+end_scan()
+{
+#ifdef READYNAS
+	if( access("/ramfs/.rescan_done", F_OK) == 0 )
+		system("/bin/sh /ramfs/.rescan_done");
+	unlink("/ramfs/.upnp-av_scan");
+#else
+	unlink("/var/notice/dlna");
+#endif
+}
--- minidlna/utils.h	2017-08-24 14:28:25.000000000 -0300
+++ minidlna/utils.h	2017-09-27 13:41:09.000000000 -0300
@@ -101,4 +101,8 @@ const char *mime_to_ext(const char * mim
 int make_dir(char * path, mode_t mode);
 unsigned int DJBHash(uint8_t *data, int len);
 
+/* Tomato */
+void begin_scan();
+void end_scan();
+
 #endif
