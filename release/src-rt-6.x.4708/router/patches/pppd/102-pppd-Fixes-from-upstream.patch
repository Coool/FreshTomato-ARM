From 4e8e41eb34f7fbc8f8a5e7ce57a43ad6472a72fc Mon Sep 17 00:00:00 2001
From: lly <lly@sf.net>
Date: Thu, 25 Mar 2010 18:41:53 -0400
Subject: [PATCH] pppd: Fixes from upstream

From 3eb9e810cfa515543655659b72dde30c54fea0a5
Subject: [PATCH] pppd: Terminate correctly if lcp_lowerup delayed calling fsm_lowerup

From cab58617fd9d328029fffabc788020264b4fa91f
Subject: [PATCH] rp_pppoe: Copy acName and pppd_pppoe_service after option parsing
---

diff --git pppd/pppd/lcp.c pppd/pppd/lcp.c
index 980bbb7..a90b3c3 100644
--- pppd/pppd/lcp.c
+++ pppd/pppd/lcp.c
@@ -400,22 +400,30 @@ lcp_close(unit, reason)
     char *reason;
 {
     fsm *f = &lcp_fsm[unit];
+    int oldstate;
     int statusindex = 0;/* JYWeng 20031216: add to wanstatus.log */
 
     if (phase != PHASE_DEAD && phase != PHASE_MASTER)
 	new_phase(PHASE_TERMINATE);
-    if (f->state == STOPPED && f->flags & (OPT_PASSIVE|OPT_SILENT)) {
+
+    if (f->flags & DELAYED_UP) {
+	untimeout(lcp_delayed_up, f);
+	f->state = STOPPED;
+    }
+    oldstate = f->state;
+
+    fsm_close(f, reason);
+    if (oldstate == STOPPED && f->flags & (OPT_PASSIVE|OPT_SILENT|DELAYED_UP)) {
 	/*
 	 * This action is not strictly according to the FSM in RFC1548,
 	 * but it does mean that the program terminates if you do a
-	 * lcp_close() in passive/silent mode when a connection hasn't
-	 * been established.
+	 * lcp_close() when a connection hasn't been established
+	 * because we are in passive/silent mode or because we have
+	 * delayed the fsm_lowerup() call and it hasn't happened yet.
 	 */
-	f->state = CLOSED;
+	f->flags &= ~DELAYED_UP;
 	lcp_finished(f);
-
-    } else
-	fsm_close(f, reason);
+    }
 /* JYWeng 20031216: add to wanstatus.log */
     if(strstr(reason, "Link inactive")) {
 	    statusindex = 1;
@@ -467,9 +475,10 @@ lcp_lowerdown(unit)
 {
     fsm *f = &lcp_fsm[unit];
 
-    if (f->flags & DELAYED_UP)
+    if (f->flags & DELAYED_UP) {
 	f->flags &= ~DELAYED_UP;
-    else
+	untimeout(lcp_delayed_up, f);
+    } else
 	fsm_lowerdown(&lcp_fsm[unit]);
 }
 
@@ -503,6 +512,7 @@ lcp_input(unit, p, len)
 
     if (f->flags & DELAYED_UP) {
 	f->flags &= ~DELAYED_UP;
+	untimeout(lcp_delayed_up, f);
 	fsm_lowerup(f);
     }
     fsm_input(f, p, len);
diff --git pppd/pppd/plugins/rp-pppoe/plugin.c pppd/pppd/plugins/rp-pppoe/plugin.c
index bb99a1a..5dd20e4 100644
--- pppd/pppd/plugins/rp-pppoe/plugin.c
+++ pppd/pppd/plugins/rp-pppoe/plugin.c
@@ -107,8 +107,6 @@ PPPOEInitDevice(void)
 	novm("PPPoE session data");
     }
     memset(conn, 0, sizeof(PPPoEConnection));
-    conn->acName = acName;
-    conn->serviceName = pppd_pppoe_service;
     conn->ifName = devnam;
     conn->discoverySocket = -1;
     conn->sessionSocket = -1;
@@ -143,6 +141,8 @@ PPPOEConnectDevice(void)
 	return -1;
     }
 
+    conn->acName = acName;
+    conn->serviceName = pppd_pppoe_service;
     strlcpy(ppp_devnam, devnam, sizeof(ppp_devnam));
     if (existingSession) {
 	unsigned int mac[ETH_ALEN];
diff --git pppd/pppd/pppd.8 pppd/pppd/pppd.8
index c148652..ce7de25 100644
--- pppd/pppd/pppd.8
+++ pppd/pppd/pppd.8
@@ -193,6 +193,9 @@ will not accept a different value from the peer in the IPCP
 negotiation, unless the \fIipcp\-accept\-local\fR and/or
 \fIipcp\-accept\-remote\fR options are given, respectively.
 .TP
+.B +ipv6
+Enable the IPv6CP and IPv6 protocols.
+.TP
 .B ipv6 \fI<local_interface_identifier>\fR,\fI<remote_interface_identifier>
 Set the local and/or remote 64-bit interface identifier. Either one may be
 omitted. The identifier must be specified in standard ascii notation of
-- 
2.10.5

